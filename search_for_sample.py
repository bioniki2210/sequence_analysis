import os
import re
import matplotlib.pyplot as plt
import scipy.stats as stats
import numpy as np


def muscle_align(infile, outfile, align_options):
    """MUSCLE alignment

    Return path to aligned fasta file;
    To perform the alignment procedure, you need to install the MEGA-X and MEGA-CC programs
    (https://www.megasoftware.net/megaccDirectDownload.php, version 10 or higher);
    infile - path to initial fasta file;
    outfile - path to aligned fasta file;
    align_options - path to mao file (MUSCLE alignment options generated by MEGA-X)"""

    command = ' '.join(['megacc', '-a', align_options, '-d', infile, '-f', 'Fasta', '-n', '-o', outfile])
    os.system(command)
    return outfile

def align_as_line(infile, outfile, remove_init_file=False):
    """Convert sequence in fasta file to line

    Return aligned fasta file with continuous sequences;
    infile - path to initial aligned fasta file;
    outfile - path to aligned fasta file with continuous sequence string;
    remove_init_file - remove initial fasta file containing blank lines (default False)"""

    # Generate temp fasta file with continuous sequences
    with open(infile, 'r') as inf, open('temp_file.fasta', 'w') as temp:
        for line in inf:
            if '>' not in line:
                line_1 = re.sub('\n$', '', line)
                temp.write(line_1)
            else:
                temp.write('\n' + line)
    temp.close()

    # Removing blank lines in fasta file
    with open('temp_file.fasta', 'r') as temp, open(outfile, 'w') as out:
        for line in temp:
            if len(line) > 2:
                out.write(line)
            else:
                continue
    os.remove('temp_file.fasta')

    # Removing initial fasta file (optional)
    if remove_init_file is True:
        os.remove(infile)
    else:
        pass
    return outfile

def seq_name(infile):
    """Get list of sequence names

    Return list of organism names (type 'numpy.ndarray');
    infile - path to fasta file"""

    name_array = np.empty((0, 1), dtype=np.chararray)
    with open(infile, 'r') as inf:
        for line in inf:
            if '>' in line:
                org_name = line.replace('>', '').strip('\n')
                name_array = np.append(org_name, name_array)
    return name_array

def seq_array(infile):
    """Get sequence array from aligned fasta file with continuous sequences

    Return array of sequences (type 'numpy.ndarray');
    infile - path to fasta file with continuous sequences"""

    sequence_array = np.empty((0, 1), dtype=np.chararray)
    with open(infile, 'r') as inf:
        for line in inf:
            if '>' not in line:
                seq = line.strip('\n')
                sequence_array = np.append(seq, sequence_array)
            else:
                continue
    return sequence_array

def get_freq_model(seq):
    """Generate nucleotide frequency model

    Return a list of nucleotide frequency dictionaries for each consensus position;
    seq - array of sequences generated from aligned fasta file (type 'numpy.ndarray')"""

    # Sequence array conversion to matrix of characters
    matrix = np.empty((len(seq), len(seq[0])), dtype=str)
    for i in range(len(seq)):
        matrix[i, :] = np.array(list(seq[i]))

    # Counting character frequencies at each consensus position
    base_occur = [{j: sum(np.char.count(j, matrix[:, i])) / len(matrix[:, i]) for j in sorted(set(matrix[:, i]))}
                  for i in range(len(matrix[0, :]))]
    return base_occur

def get_score_list(seq, model):
    """Generate array of occurrence scores for aligned sequences

    Return array of occurrence scores for each aligned sequences (type 'numpy.ndarray');
    seq - array of aligned sequences (type 'numpy.ndarray');
    model - list of nucleotide frequency dictionaries for each consensus position (type 'list')"""

    # Sum of frequencies of bases in sequence
    return np.array([sum([model[j].get(seq[i][j]) for j in range(len(seq[0]))]) for i in range(len(seq))])

def get_sample(infile, outfile, min_sample_size=15, alpha=0.05):
    """Generate representative sample of sequences

    Return path to representative sample fasta file;
    infile - path to aligned fasta file with continuous sequences (type 'str');
    outfile - path to representative fasta sample (type 'str');
    min_sample_size - minimum representative sample size (type 'int'; default 15 sequences);
    alpha - significance level (type 'float'; default 0.05);
    The representativeness of the sample is checked using the Mann-Whitney-Wilcoxon U-test;
    Null Hypothesis: For randomly chosen values of X and Y from two samples,
    the probability that X is greater than Y is equal to the probability that Y is greater than X"""

    print(infile)
    sequences = seq_array(infile)
    names = seq_name(infile)
    seq_model = get_freq_model(sequences)
    score_list = get_score_list(sequences, seq_model)

    # Get lists of sequences and names sorted by scores
    sorted_seq = [x for _, x in sorted(zip(score_list, sequences))]
    sorted_names = [x for _, x in sorted(zip(score_list, names))]

    # Formation of a small sequence sample and verification of its representativeness;
    # An initial p-value of 0 indicates that the two compared samples have a different distribution
    p_value = 0
    sample_size = min_sample_size
    while p_value < alpha:
        # Get step size to filter sequences by score
        step = round(len(sequences) / sample_size)
        with open(outfile, 'w') as out:
            if step > 1:
                # This condition is valid for the initial fasta file with
                # the number of sequences exceeding the specified sample size
                for i in range(0, len(sorted_seq), step):
                    if sorted_seq[i] is not sorted_seq[-1]:
                        out.write('>' + sorted_names[i] + '\n' + sorted_seq[i] + '\n')
                    else:
                        # The last sequence with the highest score must be included in the sample
                        out.write('>' + sorted_names[-1] + '\n' + sorted_seq[-1] + '\n')
            else:
                # In the case where the number of sequences in the initial fasta file
                # is equal to or less than the sample size, all sequences must be included in the sample
                for i in range(len(sorted_seq)):
                    out.write('>' + sorted_names[i] + '\n' + sorted_seq[i] + '\n')
            out.close()
        sampl_seq = seq_array(outfile)
        sampl_score_list = get_score_list(sampl_seq, seq_model)
        u_test = stats.mannwhitneyu(score_list, sampl_score_list)

        # QQ-plot
        seq_perc = np.percentile(score_list, range(100))
        sampl_perc = np.percentile(sampl_score_list, range(100))
        plt.scatter(x=seq_perc, y=sampl_perc, label='Actual fit')
        plt.plot(seq_perc, seq_perc, label='Line of perfect fit')
        plt.xlabel('Quantile of score value, main data')
        plt.ylabel('Quantile of score value, sample')
        plt.title('QQ-plot, ' + 'U-test ' + str(round(u_test[0])) + ', p-value ' + str(round(u_test[1], 4)))
        plt.savefig(outfile.replace('.fasta', '.png'))
        plt.close()

        # Update the current reference p-value to the one received using Mann-Whitney-Wilcoxon U-test
        p_value = u_test[1]

        # Progress
        print('U-test: ', str(round(u_test[0])), ', p-value: ', str(round(u_test[1], 4)))

        # In the case of "p-value < alpha" the sample size will increase by one sequence
        sample_size += 1
    return outfile
